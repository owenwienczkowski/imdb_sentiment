from sklearn.metrics import classification_report
def evaluate_multiclass(data, preds, truth_column_name, label_column_name, model):
    """
    Evaluates a multiclass classification model using ground-truth labels and model predictions.

    Parameters:
    - data (Dataset): The dataset containing true labels.
    - preds (list of dict): Model predictions with label strings.
    - truth_column_name (str): Column name in data holding true class labels.
    - label_column_name (str): Key in each prediction dict holding the predicted label.
    - model (str): Hugging Face model name or path.

    Returns:
    - str: Classification report as generated by scikit-learn.
    """

    # isolate actual sentiment
    y_true = list(data[truth_column_name])
    # get labels
    label_map = get_label_map(model)
    # iterate through and store classifications
    y_pred = []
    for p in preds:
        y_pred.append(label_map[p[label_column_name].lower()])
        
    # return evaluation metrics
    return classification_report(y_true, y_pred)

def evaluate_bucket(preds, label_column_name, model):
    """
    Evaluates sentiment predictions by dynamically bucketing labels into binary classes.

    Positive and negative sentiment labels are inferred from model config.
    Neutral or unknown labels are excluded from evaluation.

    Parameters:
    - preds (list of dict): Model predictions with label strings.
    - label_column_name (str): Key in each prediction dict holding the predicted label.
    - model (str): Hugging Face model name or path.

    Returns:
    - str: Binary classification report (0 = negative, 1 = positive).
    """
    # get labels
    label_map = get_label_map(model)

    # create buckets
    neg = []
    pos = []
    new_true = []
    dropped = 0 
    for k in label_map:
        if "negative" in k.lower():
            neg.append(k.lower())
        elif "positive" in k.lower():
            pos.append(k.lower())
        

    # iterate through and store classifications
    y_pred = []
    for p in preds:
        if p[label_column_name].lower() in neg:
            y_pred.append(0)
            new_true.append(0)
        elif p[label_column_name].lower() in pos:
            y_pred.append(1)
            new_true.append(1)
        else:
            dropped += 1
        
    print("Number of entries dropped (not negative or positive): ", dropped)

    # return evaluation metrics
    return classification_report(new_true, y_pred)

def get_label_map(model):
    """
    Retrieves and inverts the id2label mapping from a Hugging Face model config.

    The result maps lowercase string labels to their corresponding integer IDs.

    Parameters:
    - model (str): Hugging Face model name or path.

    Returns:
    - dict: Mapping from lowercase label strings to integer class IDs.
    """
    from transformers import AutoConfig
    config = AutoConfig.from_pretrained(model)
    inverted = {v.lower(): k for k, v in config.id2label.items()}
    return inverted